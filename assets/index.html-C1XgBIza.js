import{_ as i,c as a,a as n,o as h}from"./app-BRZjaKcj.js";const l={};function e(t,s){return h(),a("div",null,s[0]||(s[0]=[n(`<p>看下面这个例子</p><div class="language-vue line-numbers-mode" data-highlighter="shiki" data-ext="vue" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">script</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> setup</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> lang</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">ts</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 省略部分代码</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">AsyncWrapper</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> defineComponent</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">({</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">  name</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">: </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">AsyncWrapper</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  async</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> setup</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">_</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">, </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">ctx</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 获取数据</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    const </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">msg</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> await</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> getMsg</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 调用插槽函数，并传入实参 item</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> () =&gt; </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">ctx</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">slots</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">?.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">default</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">?.({ </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">msg</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> });</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  },</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">});</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">script</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">template</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  &lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">AsyncWrapper</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> v-slot</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{ </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">msg</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> }</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    &lt;!-- 传递 default 插槽函数，形参 item --&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    &lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">div</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">{{ msg }}</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">div</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  &lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">AsyncWrapper</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">template</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在当前组件中定义了一个 <code>AsyncWrapper</code> 组件，它是一个异步包装组件，在 <code>setup</code> 函数中获取数据，然后调用插槽函数，并传入实参 <code>msg</code>。</p><p>使用异步包装组件的主要作用是将异步数据加载逻辑封装在一个独立的组件中，这样做有以下几个潜在的好处：</p><h3 id="_1️⃣-逻辑抽离-提高可复用性" tabindex="-1"><a class="header-anchor" href="#_1️⃣-逻辑抽离-提高可复用性"><span>1️⃣ 逻辑抽离，提高可复用性</span></a></h3><p>如果你的项目中有多个地方需要类似的功能（比如获取某种数据并将其作为插槽内容传递给父组件），使用一个通用的 <code>AsyncWrapper</code> 可以避免重复代码，提高可复用性。</p><h3 id="_2️⃣-组件职责单一-提升代码可维护性" tabindex="-1"><a class="header-anchor" href="#_2️⃣-组件职责单一-提升代码可维护性"><span>2️⃣ 组件职责单一，提升代码可维护性</span></a></h3><p>将异步逻辑集中在 <code>AsyncWrapper</code> 中，可以让父组件的代码更加简洁，关注点也更单一。父组件只负责渲染布局，而异步数据的加载和传递则完全交由子组件处理。这样可以减少复杂度，提高代码的可读性和可维护性。</p><h3 id="_3️⃣-异步逻辑与渲染解耦" tabindex="-1"><a class="header-anchor" href="#_3️⃣-异步逻辑与渲染解耦"><span>3️⃣ 异步逻辑与渲染解耦</span></a></h3><p><code>AsyncWrapper</code> 将异步数据加载逻辑与页面渲染逻辑解耦，使得这部分异步逻辑更容易单独测试和优化。例如，如果需要更改加载数据的方式（比如增加缓存机制或切换 API），只需要修改 <code>AsyncWrapper</code> 的内部实现，父组件无需感知。</p><h3 id="_4️⃣-灵活的插槽机制" tabindex="-1"><a class="header-anchor" href="#_4️⃣-灵活的插槽机制"><span>4️⃣ 灵活的插槽机制</span></a></h3><p>通过插槽 (v-slot)，父组件可以完全控制如何渲染异步数据。这种设计模式比直接在父组件中加载数据更加灵活，比如可以让不同的父组件传递不同的渲染逻辑，而无需更改异步逻辑。</p><p>在上方的代码中，<code>AsyncWrapper</code> 提供了一个默认插槽，将 item 数据暴露给父组件，父组件可以根据自己的需求渲染内容。</p><h3 id="_5️⃣-潜在的异步状态管理" tabindex="-1"><a class="header-anchor" href="#_5️⃣-潜在的异步状态管理"><span>5️⃣ 潜在的异步状态管理</span></a></h3><p><code>AsyncWrapper</code> 组件还可以扩展为管理异步加载状态的组件，比如在数据加载完成之前显示一个加载动画，或者在请求失败时显示错误提示。这种逻辑封装在单独的组件中，可以避免重复实现。</p>`,15)]))}const k=i(l,[["render",e]]),d=JSON.parse('{"path":"/others/tfd3vwpg/","title":"异步包装组件","lang":"zh-CN","frontmatter":{"title":"异步包装组件","createTime":"2024/12/23 11:54:11","permalink":"/others/tfd3vwpg/"},"git":{"updatedTime":1734930877000,"contributors":[{"name":"evanqhu","username":"evanqhu","email":"qianghu98@163.com","commits":1,"avatar":"https://avatars.githubusercontent.com/evanqhu?v=4","url":"https://github.com/evanqhu"}]},"filePathRelative":"notes/others/async-wrapper.md","headers":[]}');export{k as comp,d as data};
