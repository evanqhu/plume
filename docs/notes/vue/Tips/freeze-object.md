---
title: 冻结对象
createTime: 2025/04/10 16:21:22
permalink: /vue/fydl77l7/
---

在 Vue 中，响应式系统是其核心特性之一。但在 Vue 2 和 Vue 3 中，它们的底层实现完全不同，特别是在**给组件中定义的变量赋值一个大对象时的性能表现差异非常明显**。下面我们来详细分析这一点。

---

### 🧠 Vue 2：响应式系统基于 `Object.defineProperty`

- Vue 2 使用 `Object.defineProperty` 将对象的属性变成响应式。
- 在赋值一个对象时，Vue 会**递归遍历这个对象的每一个属性**，为每个属性添加 `getter` 和 `setter`。
- 如果赋值的是一个嵌套层级深、数据量大的对象，性能开销非常大。

#### ⚠️ 性能问题：

```js
this.data = largeData; // 会触发递归式响应式转换，慢
```

#### ✅ 优化方法：

使用 `Object.freeze()` 冻结对象，Vue 2 会自动跳过响应式处理：

```js
this.data = Object.freeze(largeData); // 不会递归转换，性能大幅提升
```

> `Object.freeze()` 让对象变为不可变，Vue 检测到这个标志后会跳过响应式处理。

---

### ⚙️ Vue 3：响应式系统基于 `Proxy`

- Vue 3 使用 `Proxy` 重写了响应式系统。
- 代理是**懒执行**的：只有在访问属性时，才会对子属性进行代理。
- 赋值大对象时，并不会立刻递归整个结构，因此性能更好。

#### ✅ 性能更优：

```js
const state = reactive({
  info: largeData, // 只代理 info，内部属性直到访问才会处理
});
```

> 由于 Vue 3 是惰性代理，所以不需要像 Vue 2 那样手动使用 `Object.freeze()` 来优化性能。

---

### 📌 对比总结

| 特性                              | Vue 2                   | Vue 3        |
| --------------------------------- | ----------------------- | ------------ |
| 响应式实现方式                    | `Object.defineProperty` | `Proxy`      |
| 是否递归处理对象属性              | 是                      | 否，懒处理   |
| 大对象赋值性能                    | 较差                    | 优秀         |
| 是否需要使用 `Object.freeze` 优化 | 是                      | 否           |
| 响应式转换触发时机                | 赋值时立即递归          | 访问时再代理 |

---

### ✅ 最佳实践建议

- 在 **Vue 2** 中，如果你赋值的是不需要响应的**大对象（如后端传来的原始数据）**，请使用 `Object.freeze()`。
- 在 **Vue 3** 中，你**不需要做任何处理**，性能已经足够优秀。
